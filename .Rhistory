dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
mtext(paste0("Sparsity levels (", nonz[1], ", ", nonz[2], ")"), side = 3)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title("estimated change of the mean of the latent variables with time", outer=T, line=-1)
mtext(paste0("Sparsity levels (", nonz[1], ", ", nonz[2], ")"), side = 3)
}
}
#########################################################################################################################################################################################################
estimate4_ab = function(X, Y, lmeformule=NA, alpha=1, lambda=0.0005, eps = 0.001, maxiter=100) {
# criss-cross algorithm without assuming X and Y are matrices with the same numer of rows
if (is.na(lmeformule)) {lmeformule=" ~ -1 + time + (1|id)"}
library(lme4)
library(glmnet)
id_x = X[,"id"]
id_y = Y[,"id"]
time_x = X[,"time"]
time_y = Y[,"time"]
# step 0: initialize weight-vector a
a = rep(1, (ncol(X)-2))/(ncol(X)-2)
b = rep(0, (ncol(Y)-2))/(ncol(Y)-2)
iter = 0
conv = 1
while (conv > eps & iter <= maxiter) {
iter = iter + 1
# step 1: calculate theta's using current value of the a-vector
theta = as.matrix(X[,-c(1,2)]) %*% a
ff1 = data.frame(theta=theta, time=time_x, id=id_x)
ff2 = lmer(as.formula(paste("theta", lmeformule)), data=ff1, REML=TRUE)
ff3 = predict(ff2, newdata=data.frame(time=time_y, id=id_y), allow.new.levels=TRUE, re.form=NULL)
# step 2: regress predicted-theta on Y and obtain the b-vector
bnew=glmnet(y = ff3, x = Y[,-c(1,2)], family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
rm(ff1, ff2, ff3)
# step 3: calculate xi's using current value of the b-vector and stack and scale xi's
xi = as.matrix(Y[, -c(1,2)]) %*% bnew
ff1 = data.frame(xi=xi, time=time_y, id=id_y)
ff2 = lmer(as.formula(paste("xi", lmeformule)), data=ff1, REML=TRUE)
ff3 = predict(ff2, newdata=data.frame(time=time_x, id=id_x), allow.new.levels=TRUE, re.form=NULL)
# step 4: re-calculate the a-vector a by regression of stacked_xi on stacked_X
anew = glmnet(y = ff3, x = X[,-c(1,2)], family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
rm(ff1, ff2, ff3)
# step 5: check convergence
conv = max(c(abs(a-anew), abs(b-bnew)))
a = anew
b = bnew
}
return(list(a=anew, b=bnew, conv=conv, iter=iter))
}
#########################################################################################################################################################################################################
descriptives = function(X, Y, plotit=TRUE, k=16, lmeformule=NA) {
ggmin1="                    "
gg0=data.frame(kol1=" ", kol1a=ggmin1, kol2=" ")
gg1=data.frame(kol1=paste("number of records: ", nrow(X),sep=""), kol1a=ggmin1, kol2=paste("number of records: ", nrow(Y), sep=""))
id_x = unique(X[,1])
id_y = unique(Y[,1])
nxy=which(id_x %in% id_y)
nyx=which(id_x %in% id_y)
gg2=data.frame(kol1=paste("subjects: ", length(id_x),sep=""), kol1a=ggmin1, kol2=paste("subjects: ", length(id_y),sep=""))
gg2a=aggregate(rep(1,nrow(X)), by=list(X[,1]), FUN=sum)[,2]
gg2b=aggregate(rep(1,nrow(Y)), by=list(Y[,1]), FUN=sum)[,2]
gg2c=data.frame(kol1=paste("mean (SD) number of repeated measures/subject: ",round(mean(gg2a),3), " (",round(sd(gg2a),3),")", sep=""), kol1a=ggmin1,
kol2=paste("mean (SD) number of repeated measures/subject: ",round(mean(gg2b),3), " (",round(sd(gg2b),3),")", sep=""))
gg3=data.frame(kol1=paste("number of X-subjects in Y: ", length(nxy), sep=""), kol1a=ggmin1, kol2=paste("number of Y-subjects in X: ", length(nyx),sep=""))
p = ncol(X) - 2
q = ncol(Y) - 2
gg4=data.frame(kol1=paste("numer of x-variables: ", p,sep=""), kol1a="     ", kol2=paste("number of y-variables: ", q, sep=""))
time_x = X[,2]
time_y = X[,2]
kx=unique(time_x)
ky=unique(time_y)
gg5=data.frame(kol1=paste("number of time-points: ", length(kx),sep=""), kol1a=ggmin1, kol2=paste("number of time-points: ", length(ky),sep=""))
gg6=data.frame(kol1=paste("mean of time-points: ", round(mean(X[,2]),3), sep=""), kol1a=ggmin1, kol2=paste("mean of time-points: ", round(mean(Y[,2]),3),sep=""))
gg7=data.frame(kol1=paste("SD of time-points: ", round(sd(X[,2]),3),sep=""), kol1a=ggmin1, kol2=paste("SD of time-points: ", round(sd(Y[,2]),3),sep=""))
gg10=rbind(gg0, gg1, gg2,gg2c, gg3, gg0,gg4,gg0,gg5,gg6,gg7,gg0)
names(gg10)[c(1,2,3)]=c("X-variables", "" , "Y-variables")
row.names(gg10)=1:nrow(gg10)
print(noquote(gg10))
if (length(kx) <= 10 & length(ky) <= 10) {
ff1=table(X[,2])
ff2=table(Y[,2])
ff1=data.frame(tp=as.numeric(names(ff1)),aantalx=as.numeric(ff1))
ff2=data.frame(tp=as.numeric(names(ff2)),aantaly=as.numeric(ff2))
names(ff1)=c("time-point","occurring in X")
names(ff2)=c("time-point","occurring in Y")
ff3=merge(ff1,ff2)
print(ff3)
}
if (length(kx) > 10 | length(ky) > 10) {
dev.new()
par(mfrow=c(1,2))
hist(X[,2], xlab="time-points", main="x-variables")
hist(Y[,2], xlab="time-points", main="y-variables")
}
if (plotit) {
if(is.na(lmeformule)) {lmeformule="~ time + (1|id)"}
if (k > 16) {k=16}
ff1=c(4,4) * (k > 9) + c(3,3) * (k <= 9) * (k > 4) + c(2,2) * (k <= 4) * (k > 1) + c(1,1) * (k==1)
dev.new()
par(mfrow=ff1)
library(lme4)
selectie_x = sort(sample(1:p,k,replace=FALSE))
i = selectie_x[1]
for (i in selectie_x) {
id=X[,1]
time =X[,2]
zvar=X[,(i+2)]
ff2 = lmer(as.formula(paste("zvar",lmeformule)))
ff3 = predict(ff2, newdata=data.frame(time=sort(unique(c(time_x, time_y))), id = -1), allow.new.levels=TRUE, re.form=NA)
plot(time, zvar, xlab="time", ylab=paste("x-variable:",i), ylim=c(min(zvar,ff3),max(zvar,ff3)), xlim=c(min(sort(unique(c(time_x, time_y)))), max(sort(unique(c(time_x, time_y))))))
lines(sort(unique(c(time_x, time_y))), ff3, lwd=2, col=3)
}
dev.new()
par(mfrow=ff1)
selectie_y = sort(sample(1:q,k,replace=FALSE))
i = selectie_y[1]
for (i in selectie_y) {
id=Y[,1]
time =Y[,2]
zvar=Y[,(i+2)]
ff2 = lmer(as.formula(paste("zvar",lmeformule)))
ff3 = predict(ff2, newdata=data.frame(time=sort(unique(c(time_x, time_y))), id = -1), allow.new.levels=TRUE, re.form=NA)
plot(time, zvar, xlab="time", ylab=paste("y-variable:",i), ylim=c(min(zvar,ff3),max(zvar,ff3)), xlim=c(min(sort(unique(c(time_x, time_y)))), max(sort(unique(c(time_x, time_y))))))
lines(sort(unique(c(time_x, time_y))), ff3, lwd=2, col=3)
}
}
}
#########################################################################################################################################################################################################
estimate0_ab = function(X, Y, alpha=1, lambda=0.0005, eps = 0.001, maxiter=100) {
# criss-cross algorithm assuming that X and Y are matrices with the same numbers of rows
library(glmnet)
a = rep(1, ncol(X))/ncol(X)
b = rep(0, ncol(Y))/ncol(Y)
iter = 0
conv = 1
while (conv > eps & iter <= maxiter) {
iter = iter + 1
# step 1: calculate theta's using current value of the a-vector
theta = as.matrix(X) %*% a
# step 2: regress theta on Y to obtain the b-vector
bnew = glmnet(y = (theta), x = Y, family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
# step 3: calculate xi's using current value of the b-vector and stack and scale xi's
xi = as.matrix(Y) %*% bnew
# step 4: re-calculate the a-vector a by regression of xi on X
anew = glmnet(y = (xi), x = X, family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
# step 5: check convergence
conv = max(c(abs(a-anew), abs(b-bnew)))
a = anew
b = bnew
}
return(list(a=anew, b=bnew, conv=conv, iter=iter))
}
#########################################################################################################################################################################################################
do_separate_lmes=function(Z, lmeformule=NA) {
library(lme4)
if (is.na(lmeformule)) {lmeformule=" ~ 1 + time + (1|id)"}
id=Z[,1]
time=Z[,2]
j=1
zvar=Z[,(j+2)]
ff1=lmer(as.formula(paste("zvar",lmeformule)))
ff2=ranef(ff1)$id
randomeffects=as.data.frame(matrix(NA, nrow=nrow(ff2), ncol=ncol(ff2)*(ncol(Z)-2)))
randomeffects[,1:ncol(ff2)]=ff2
j=2
for (j in 2:(ncol(Z)-2)) {
zvar=Z[,(j+2)]
ff1=lmer(as.formula(paste("zvar",lmeformule)))
ff2=ranef(ff1)$id
randomeffects[,((ncol(ff2)*(j-1)+1) : (ncol(ff2)*(j-1)+ncol(ff2)) )]=ff2
if ((j||100)==0) {print(paste("variable:",j))}
}
return(randomeffects)
}
#########################################################################################################################################################################################################
makeplots0 = function(X, Y, resx, weigths=TRUE, loadings=FALSE) {
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
}
if(loadings) {
theta = as.matrix(X) %*% resx$a
xi = as.matrix(Y) %*% resx$b
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X, as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y, as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
}
}
nonz_a = 100
nonz_b = 50
res_toscca = toscca.core(alphaInit = runif(ncol(X)-2), X, Y, nonz_a, nonz_b, lmeformula = " ~ poly(time,3) + (1|id)")
####################################################################################
####################################################################################
###                                                                              ###
### penalized CCA of X and Y-matrices with sets of x- and y-variables measured   ###
###  at varying numbers of time-points with the criss-cross algorithm            ###
###                                                                              ###
####################################################################################
####################################################################################
scalar1 <- function(x) {x / sqrt(sum(x^2))}
library(lme4)
nonz_a = 100
nonz_b = 50
res_toscca = toscca.core(alphaInit = runif(ncol(X)-2), X, Y, nonz_a, nonz_b, lmeformula = " ~ poly(time,3) + (1|id)")
c(res_toscca$conv, res_toscca$iter)
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
plotsofpatientsof1variable(X, set="X", number=1, res_toscca, k=16, lmeformule=" ~ poly(time,3) + (1|id)"); dev.new()
plotsofselectedvariables(X, set="X", variables=1:20, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)"); dev.new()
plotsofselectedvariables(Y, set="Y", variables=1:10, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)")
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
if (is.na(lmeformule)) {lmeformule=" ~ time + (1|id)"}
library(lme4)
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
title(paste0("estimated change of the mean of the latent variables with time. sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
theta = (as.matrix(X[,-c(1,2)]) %*% resx$a); if(scale == TRUE) {theta = scalar1(theta)}
xi = (as.matrix(Y[,-c(1,2)]) %*% resx$b); if(scale == TRUE) {xi = scalar1(xi)}
if(loadings) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
title(paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title(paste0("estimated change of the mean of the latent variables with time. sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
if (is.na(lmeformule)) {lmeformule=" ~ time + (1|id)"}
library(lme4)
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
title(paste0("estimated change of the mean of the latent variables with time. sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
theta = (as.matrix(X[,-c(1,2)]) %*% resx$a); if(scale == TRUE) {theta = scalar1(theta)}
xi = (as.matrix(Y[,-c(1,2)]) %*% resx$b); if(scale == TRUE) {xi = scalar1(xi)}
if(loadings) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
title(paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title(paste0("estimated change of the mean of the latent variables with time.", '\n', "sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
if (is.na(lmeformule)) {lmeformule=" ~ time + (1|id)"}
library(lme4)
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
title(paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
theta = (as.matrix(X[,-c(1,2)]) %*% resx$a); if(scale == TRUE) {theta = scalar1(theta)}
xi = (as.matrix(Y[,-c(1,2)]) %*% resx$b); if(scale == TRUE) {xi = scalar1(xi)}
if(loadings) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
title(paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title("estimated change of the mean of the latent variables with time", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
if (is.na(lmeformule)) {lmeformule=" ~ time + (1|id)"}
library(lme4)
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
title("canonical weights", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
theta = (as.matrix(X[,-c(1,2)]) %*% resx$a); if(scale == TRUE) {theta = scalar1(theta)}
xi = (as.matrix(Y[,-c(1,2)]) %*% resx$b); if(scale == TRUE) {xi = scalar1(xi)}
if(loadings) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
title("correlations", subpaste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title("estimated change of the mean of the latent variables with time", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
}
makeplots = function(X, Y, resx, lmeformule=NA, weigths=TRUE, loadings=FALSE, change=FALSE, scale = FALSE, nonz = "") {
if (is.na(lmeformule)) {lmeformule=" ~ time + (1|id)"}
library(lme4)
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
title("canonical weights", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
theta = (as.matrix(X[,-c(1,2)]) %*% resx$a); if(scale == TRUE) {theta = scalar1(theta)}
xi = (as.matrix(Y[,-c(1,2)]) %*% resx$b); if(scale == TRUE) {xi = scalar1(xi)}
if(loadings) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X[,-c(1,2)], as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y[,-c(1,2)], as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
title("correlations", sub =paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title("estimated change of the mean of the latent variables with time", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
nonz_a = 10
nonz_b = 5
res_toscca = toscca.core(alphaInit = runif(ncol(X)-2), X, Y, nonz_a, nonz_b, lmeformula = " ~ poly(time,3) + (1|id)")
c(res_toscca$conv, res_toscca$iter)
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
dim(X)
dim(Y)
nonz_a = 9000
nonz_b = 80
res_toscca = toscca.core(alphaInit = runif(ncol(X)-2), X, Y, nonz_a, nonz_b, lmeformula = " ~ poly(time,3) + (1|id)")
c(res_toscca$conv, res_toscca$iter)
makeplots(X, Y, res_toscca, lmeformule=" ~ poly(time,3) + (1|id)", weigths=TRUE, loadings=TRUE, change=TRUE, scale = T, nonz = c(nonz_a, nonz_b)); dev.new()
