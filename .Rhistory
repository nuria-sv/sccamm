if(change) {
dev.new()
rangorde = order(X[,"time"], X[,"id"])
X=X[rangorde,]
id = X[,"id"]
time = X[,"time"]
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
par(mfrow=c(1,2))
ff1 = aggregate(theta, by=list(time), FUN=mean)
ff3 = lmer(as.formula(paste("theta", lmeformule)), data = data.frame(X))
ff4 = predict(ff3, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff1[,1], ff1[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the X-variables", ylim=c(min(ff1[,2],ff4),max(ff1[,2],ff4)))
lines(sort(unique(time)), ff4, col=2, lwd=2)
rangorde = order(Y[,"time"], Y[,"id"])
Y=Y[rangorde,]
id = Y[,"id"]
time = Y[,"time"]
ff2 = aggregate(xi, by=list(time), FUN=mean)
ff5 = lmer(as.formula(paste("xi", lmeformule)), data = data.frame(Y))
ff6 = predict(ff5, newdata=data.frame(time=sort(unique(time)), id=-1), re.form=NA, allow.new.levels=TRUE)
plot(ff2[,1], ff2[,2], type="b", xlab="time-point", ylab="mean of the latent variable of the Y-variables", ylim=c(min(ff2[,2],ff6),max(ff2[,2],ff6)))
lines(sort(unique(time)), ff6, col=3, lwd=2)
title("estimated change of the mean of the latent variables with time", sub = paste0("sparsity levels (", nonz[1], ", ", nonz[2], ")"), outer=T, line=-1)
}
}
#########################################################################################################################################################################################################
estimate4_ab = function(X, Y, lmeformule=NA, alpha=1, lambda=0.0005, eps = 0.001, maxiter=100) {
# criss-cross algorithm without assuming X and Y are matrices with the same numer of rows
if (is.na(lmeformule)) {lmeformule=" ~ -1 + time + (1|id)"}
library(lme4)
library(glmnet)
id_x = X[,"id"]
id_y = Y[,"id"]
time_x = X[,"time"]
time_y = Y[,"time"]
# step 0: initialize weight-vector a
a = rep(1, (ncol(X)-2))/(ncol(X)-2)
b = rep(0, (ncol(Y)-2))/(ncol(Y)-2)
iter = 0
conv = 1
while (conv > eps & iter <= maxiter) {
iter = iter + 1
# step 1: calculate theta's using current value of the a-vector
theta = as.matrix(X[,-c(1,2)]) %*% a
ff1 = data.frame(theta=theta, time=time_x, id=id_x)
ff2 = lmer(as.formula(paste("theta", lmeformule)), data=ff1, REML=TRUE)
ff3 = predict(ff2, newdata=data.frame(time=time_y, id=id_y), allow.new.levels=TRUE, re.form=NULL)
# step 2: regress predicted-theta on Y and obtain the b-vector
bnew=glmnet(y = ff3, x = Y[,-c(1,2)], family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
rm(ff1, ff2, ff3)
# step 3: calculate xi's using current value of the b-vector and stack and scale xi's
xi = as.matrix(Y[, -c(1,2)]) %*% bnew
ff1 = data.frame(xi=xi, time=time_y, id=id_y)
ff2 = lmer(as.formula(paste("xi", lmeformule)), data=ff1, REML=TRUE)
ff3 = predict(ff2, newdata=data.frame(time=time_x, id=id_x), allow.new.levels=TRUE, re.form=NULL)
# step 4: re-calculate the a-vector a by regression of stacked_xi on stacked_X
anew = glmnet(y = ff3, x = X[,-c(1,2)], family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
rm(ff1, ff2, ff3)
# step 5: check convergence
conv = max(c(abs(a-anew), abs(b-bnew)))
a = anew
b = bnew
}
return(list(a=anew, b=bnew, conv=conv, iter=iter))
}
#########################################################################################################################################################################################################
descriptives = function(X, Y, plotit=TRUE, k=16, lmeformule=NA) {
ggmin1="                    "
gg0=data.frame(kol1=" ", kol1a=ggmin1, kol2=" ")
gg1=data.frame(kol1=paste("number of records: ", nrow(X),sep=""), kol1a=ggmin1, kol2=paste("number of records: ", nrow(Y), sep=""))
id_x = unique(X[,1])
id_y = unique(Y[,1])
nxy=which(id_x %in% id_y)
nyx=which(id_x %in% id_y)
gg2=data.frame(kol1=paste("subjects: ", length(id_x),sep=""), kol1a=ggmin1, kol2=paste("subjects: ", length(id_y),sep=""))
gg2a=aggregate(rep(1,nrow(X)), by=list(X[,1]), FUN=sum)[,2]
gg2b=aggregate(rep(1,nrow(Y)), by=list(Y[,1]), FUN=sum)[,2]
gg2c=data.frame(kol1=paste("mean (SD) number of repeated measures/subject: ",round(mean(gg2a),3), " (",round(sd(gg2a),3),")", sep=""), kol1a=ggmin1,
kol2=paste("mean (SD) number of repeated measures/subject: ",round(mean(gg2b),3), " (",round(sd(gg2b),3),")", sep=""))
gg3=data.frame(kol1=paste("number of X-subjects in Y: ", length(nxy), sep=""), kol1a=ggmin1, kol2=paste("number of Y-subjects in X: ", length(nyx),sep=""))
p = ncol(X) - 2
q = ncol(Y) - 2
gg4=data.frame(kol1=paste("numer of x-variables: ", p,sep=""), kol1a="     ", kol2=paste("number of y-variables: ", q, sep=""))
time_x = X[,2]
time_y = X[,2]
kx=unique(time_x)
ky=unique(time_y)
gg5=data.frame(kol1=paste("number of time-points: ", length(kx),sep=""), kol1a=ggmin1, kol2=paste("number of time-points: ", length(ky),sep=""))
gg6=data.frame(kol1=paste("mean of time-points: ", round(mean(X[,2]),3), sep=""), kol1a=ggmin1, kol2=paste("mean of time-points: ", round(mean(Y[,2]),3),sep=""))
gg7=data.frame(kol1=paste("SD of time-points: ", round(sd(X[,2]),3),sep=""), kol1a=ggmin1, kol2=paste("SD of time-points: ", round(sd(Y[,2]),3),sep=""))
gg10=rbind(gg0, gg1, gg2,gg2c, gg3, gg0,gg4,gg0,gg5,gg6,gg7,gg0)
names(gg10)[c(1,2,3)]=c("X-variables", "" , "Y-variables")
row.names(gg10)=1:nrow(gg10)
print(noquote(gg10))
if (length(kx) <= 10 & length(ky) <= 10) {
ff1=table(X[,2])
ff2=table(Y[,2])
ff1=data.frame(tp=as.numeric(names(ff1)),aantalx=as.numeric(ff1))
ff2=data.frame(tp=as.numeric(names(ff2)),aantaly=as.numeric(ff2))
names(ff1)=c("time-point","occurring in X")
names(ff2)=c("time-point","occurring in Y")
ff3=merge(ff1,ff2)
print(ff3)
}
if (length(kx) > 10 | length(ky) > 10) {
dev.new()
par(mfrow=c(1,2))
hist(X[,2], xlab="time-points", main="x-variables")
hist(Y[,2], xlab="time-points", main="y-variables")
}
if (plotit) {
if(is.na(lmeformule)) {lmeformule="~ time + (1|id)"}
if (k > 16) {k=16}
ff1=c(4,4) * (k > 9) + c(3,3) * (k <= 9) * (k > 4) + c(2,2) * (k <= 4) * (k > 1) + c(1,1) * (k==1)
dev.new()
par(mfrow=ff1)
library(lme4)
selectie_x = sort(sample(1:p,k,replace=FALSE))
i = selectie_x[1]
for (i in selectie_x) {
id=X[,1]
time =X[,2]
zvar=X[,(i+2)]
ff2 = lmer(as.formula(paste("zvar",lmeformule)))
ff3 = predict(ff2, newdata=data.frame(time=sort(unique(c(time_x, time_y))), id = -1), allow.new.levels=TRUE, re.form=NA)
plot(time, zvar, xlab="time", ylab=paste("x-variable:",i), ylim=c(min(zvar,ff3),max(zvar,ff3)), xlim=c(min(sort(unique(c(time_x, time_y)))), max(sort(unique(c(time_x, time_y))))))
lines(sort(unique(c(time_x, time_y))), ff3, lwd=2, col=3)
}
dev.new()
par(mfrow=ff1)
selectie_y = sort(sample(1:q,k,replace=FALSE))
i = selectie_y[1]
for (i in selectie_y) {
id=Y[,1]
time =Y[,2]
zvar=Y[,(i+2)]
ff2 = lmer(as.formula(paste("zvar",lmeformule)))
ff3 = predict(ff2, newdata=data.frame(time=sort(unique(c(time_x, time_y))), id = -1), allow.new.levels=TRUE, re.form=NA)
plot(time, zvar, xlab="time", ylab=paste("y-variable:",i), ylim=c(min(zvar,ff3),max(zvar,ff3)), xlim=c(min(sort(unique(c(time_x, time_y)))), max(sort(unique(c(time_x, time_y))))))
lines(sort(unique(c(time_x, time_y))), ff3, lwd=2, col=3)
}
}
}
#########################################################################################################################################################################################################
estimate0_ab = function(X, Y, alpha=1, lambda=0.0005, eps = 0.001, maxiter=100) {
# criss-cross algorithm assuming that X and Y are matrices with the same numbers of rows
library(glmnet)
a = rep(1, ncol(X))/ncol(X)
b = rep(0, ncol(Y))/ncol(Y)
iter = 0
conv = 1
while (conv > eps & iter <= maxiter) {
iter = iter + 1
# step 1: calculate theta's using current value of the a-vector
theta = as.matrix(X) %*% a
# step 2: regress theta on Y to obtain the b-vector
bnew = glmnet(y = (theta), x = Y, family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
# step 3: calculate xi's using current value of the b-vector and stack and scale xi's
xi = as.matrix(Y) %*% bnew
# step 4: re-calculate the a-vector a by regression of xi on X
anew = glmnet(y = (xi), x = X, family="gaussian", alpha=alpha, lambda=lambda, intercept=FALSE)$beta[,1]
# step 5: check convergence
conv = max(c(abs(a-anew), abs(b-bnew)))
a = anew
b = bnew
}
return(list(a=anew, b=bnew, conv=conv, iter=iter))
}
#########################################################################################################################################################################################################
do_separate_lmes=function(Z, lmeformule=NA) {
library(lme4)
if (is.na(lmeformule)) {lmeformule=" ~ 1 + time + (1|id)"}
id=Z[,1]
time=Z[,2]
j=1
zvar=Z[,(j+2)]
ff1=lmer(as.formula(paste("zvar",lmeformule)))
ff2=ranef(ff1)$id
randomeffects=as.data.frame(matrix(NA, nrow=nrow(ff2), ncol=ncol(ff2)*(ncol(Z)-2)))
randomeffects[,1:ncol(ff2)]=ff2
j=2
for (j in 2:(ncol(Z)-2)) {
zvar=Z[,(j+2)]
ff1=lmer(as.formula(paste("zvar",lmeformule)))
ff2=ranef(ff1)$id
randomeffects[,((ncol(ff2)*(j-1)+1) : (ncol(ff2)*(j-1)+ncol(ff2)) )]=ff2
if ((j||100)==0) {print(paste("variable:",j))}
}
return(randomeffects)
}
#########################################################################################################################################################################################################
makeplots0 = function(X, Y, resx, weigths=TRUE, loadings=FALSE) {
if(weigths) {
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a), resx$a, xlab="variable number", ylab="weights of X-variables")
abline(h=0)
plot(1:length(resx$b), resx$b, xlab="variable number", ylab="weights of Y-variables")
abline(h=0)
}
if(loadings) {
theta = as.matrix(X) %*% resx$a
xi = as.matrix(Y) %*% resx$b
dev.new()
par(mfrow=c(1,2))
plot(1:length(resx$a) , cor(X, as.numeric(theta)), xlab="variable number", ylab="loadings of X-variables on theta")
abline(h=0)
plot(1:length(resx$b) , cor(Y, as.numeric(xi))   , xlab="variable number", ylab="loadings of Y-variables on xi")
abline(h=0)
}
}
dev.new()
makeplots(XX2, YY2, res_toscca, lmeformule=" ~ poly(time,3) + (1+time|id)", weigths=TRUE, loadings=TRUE, change=TRUE); dev.new()
plotsofpatientsof1variable(XX2, set="X", number=1, res_toscca, k=16, lmeformule=" ~ poly(time,3) + (1|id)"); dev.new()
plotsofpatientsof1variable(XX2, set="X", number=1, res_toscca, k=16, lmeformule=" ~ poly(time,3) + (1|id)"); dev.new()
# res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, lmeformula = " ~ 0 + poly(time,3) + (1|id)")
res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, model = "arima", arformula = NULL) # c(1,1,0)
arformula = NULL
A = XX2
B = YY2
alpha = sapply(nonzero_a, function(x) c(alphaInit))
varTol1 = matrix(0, nrow = nrow(A), ncol = length(nonzero_a))
varTol2 = matrix(0, nrow = nrow(B), ncol = length(nonzero_b))
i = 0
e = 10
# format data
id_a = A[,"id"]
id_b = B[,"id"]
time_a = A[,"time"]
time_b = B[,"time"]
A = as.matrix(A[, 3:ncol(A)])
B = as.matrix(B[, 3:ncol(B)])
i = i +1
# refresh
if(i > 1) varTol1 = gamma
if(i > 1) varTol2 = zeta
gamma =  A %*% alpha
dist  = sqrt(colSums(gamma^2))
gamma = sweep(gamma, 2, dist, "/")
if(length(model) != 1 | !(model %in% c("arima", "lme"))) {
model = "lme"
lmeformula = " ~ -1 + time + (1|id)"
print("Model not correctly specify. \n Default is lme with formula ~ -1 + time + (1|id)")
}
if(model == "arima") {
me = list()
pred_me = matrix(NA, nrow(B), 1)
if(is.null(arformula)){
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_a)){
me[[n]] = arima(gamma[n == id_a], order = arformula, method = "ML")
}
}
for(n in unique(id_a)){
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
}
pred_me
me[[1]]
me[[5]]
me[[67]]
beta = t(B) %*% pred_me
rm(me, pred_me)
beta = apply(rbind(beta,nonzero_b), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
zeta = B %*% beta
dist = sqrt(colSums(zeta^2))
zeta = sweep(zeta, 2, dist, "/")
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
}
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_a == n)]))$pred)
}
}
me = list()
pred_me = matrix(NA, length(gamma), 1)
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_a == n)]))$pred)
}
n
time_b[which(id_a == n)]
is.na(time_b)
table(is.na(time_b))
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar.R")
# res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, lmeformula = " ~ 0 + poly(time,3) + (1|id)")
res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, model = "arima", arformula = NULL) # c(1,1,0)
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
}
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
}
time_a[which(id_a == n)]
time_b[which(id_b == n)]
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
for(n in unique(id_a)){
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
beta = t(B) %*% pred_me
rm(me, pred_me)
pred_me
for(n in unique(id_a)){
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
if(model == "arima") {
me = list()
pred_me = matrix(NA, nrow(B), 1)
if(is.null(arformula)){
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_a)){
me[[n]] = arima(gamma[n == id_a], order = arformula, method = "ML")
}
}
for(n in unique(id_a)){
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
}
length(pred_me)
dim(B)
beta = t(B) %*% pred_me
rm(me, pred_me)
beta = apply(rbind(beta,nonzero_b), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
zeta = B %*% beta
dist = sqrt(colSums(zeta^2))
zeta = sweep(zeta, 2, dist, "/")
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
}
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
}
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
}
}
dim(pred_me)
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
n
time_a[which(id_a == n)]
me[[n]]
as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))
time_b[which(id_b == n)]
time_a[which(id_a == n)]
zeta[n == id_b]
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
me = list()
pred_me = matrix(NA, length(gamma), 1)
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
}
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
for(n in unique(id_b)){
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$pred)
}
s.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$pred)
as.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$pred)
length(time_a[which(id_a == n)])
(forecast(me[[n]], h = length(time_a[which(id_a == n)]))
)
n
x=forecast(me[[n]], h = length(time_a[which(id_a == n)]))
x$fitted
me = list()
pred_me = matrix(NA, nrow(B), 1)
if(is.null(arformula)){
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_b ==n)] = as.numeric(forecast(me[[n]], h = length(time_b[which(id_b == n)]))$fitted)
}
} else {
for(n in unique(id_a)){
me[[n]] = arima(gamma[n == id_a], order = arformula, method = "ML")
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
}
# for(n in unique(id_a)){
#   pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
# }
}
if(model == "lme") {
me = lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma, time = time_a, id = id_a), REML = TRUE)
pred_me = predict(me, newdata = data.frame(time = time_b, id = id_b), allow.new.levels = TRUE, re.form = NULL)
}
beta = t(B) %*% pred_me
rm(me, pred_me)
beta = apply(rbind(beta,nonzero_b), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
zeta = B %*% beta
dist = sqrt(colSums(zeta^2))
zeta = sweep(zeta, 2, dist, "/")
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$fitted)
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
}
# for(n in unique(id_b)){
#   pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
# }
}
if(model == "lme") {
me = lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta, time = time_a, id = id_a), REML = TRUE)
pred_me = predict(me, newdata = data.frame(time = time_b, id = id_b), allow.new.levels = TRUE, re.form = NULL)
}
alpha = t(A) %*% pred_me
rm(me, pred_me)
alpha = apply(rbind(alpha,nonzero_a), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
if(length(nonzero_a) == 1) e = mean(abs(gamma - varTol1)) + mean(abs(zeta - varTol2))
if(length(nonzero_a) > 1) e  = mean(colMeans(abs(gamma - varTol1))) + mean(colMeans(abs(zeta - varTol2)))
textSCCA = paste0(" Common convergence error: ", round(e, 5), " & Iterations: ", i)
if(isFALSE(silent) & (e<= tol || i > iter)) cat(textSCCA, "\r")
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar.R")
# res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, lmeformula = " ~ 0 + poly(time,3) + (1|id)")
res_toscca = toscca.core(alphaInit = runif(ncol(XX2)-2), XX2, YY2, 50, 50, model = "arima", arformula = NULL) # c(1,1,0)
c(res_toscca$conv, res_toscca$iter)
makeplots(XX2, YY2, res_toscca, lmeformule=" ~ poly(time,3) + (1+time|id)", weigths=TRUE, loadings=TRUE, change=TRUE); dev.new()
