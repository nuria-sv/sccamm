if(length(nonzero_a) == 1) e = mean(abs(gamma - varTol1)) + mean(abs(zeta - varTol2))
if(length(nonzero_a) > 1) e  = mean(colMeans(abs(gamma - varTol1))) + mean(colMeans(abs(zeta - varTol2)))
textSCCA = paste0(" Common convergence error: ", round(e, 5), " & Iterations: ", i)
if(isFALSE(silent) & (e<= tol || i > iter)) cat(textSCCA, "\r")
}
if(model == "lme") {
me_x = lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma, time = time_a, id = id_a), REML = TRUE)
me_y = lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta, time = time_b, id = id_b), REML = TRUE)
} else {
me_x = NULL
me_y = NULL
}
return(list(a = alpha, b = beta, conv = e, iter = i, me_x = me_x, me_y = me_y))
}
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
# toscca ME linear
toscca.core = function(alphaInit, A, B, nonzero_a, nonzero_b, iter = 20, tol = 10^(-6), silent = FALSE, model = c("arima", "lme"), arformula = c(1,0,0), lmeformula = " ~ -1 + time + (1|id)")
{
list.of.packages <- c("lme4", "forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
# checks
if(ncol(B) <= max(nonzero_b)) {
message("At least one of the nonzero options for B is not sparse. Changing to meet criteria")
nonzeroB = nonzero_b[nonzero_b < (ncol(B) - 2)]
}
if(ncol(A) <= max(nonzero_a)) {
message("At least one of the nonzero options for A is not sparse. Changing to meet criteria")
nonzero_a = nonzero_a[nonzero_a < (ncol(A) - 2)]
}
#Create the matrix A
alpha = sapply(nonzero_a, function(x) c(alphaInit))
varTol1 = matrix(0, nrow = nrow(A), ncol = length(nonzero_a))
varTol2 = matrix(0, nrow = nrow(B), ncol = length(nonzero_b))
i = 0
e = 10
# format data
id_a = A[,"id"]
id_b = B[,"id"]
time_a = A[,"time"]
time_b = B[,"time"]
A = as.matrix(A[, 3:ncol(A)])
B = as.matrix(B[, 3:ncol(B)])
while (e > tol & i <= iter) {
i = i +1
# refresh
if(i > 1) varTol1 = gamma
if(i > 1) varTol2 = zeta
gamma =  A %*% alpha
dist  = sqrt(colSums(gamma^2))
gamma = sweep(gamma, 2, dist, "/")
if(length(model) != 1 | !(model %in% c("arima", "lme"))) {
model = "lme"
lmeformula = " ~ -1 + time + (1|id)"
print("Model not correctly specify. \n Default is lme with formula ~ -1 + time + (1|id)")
}
if(model == "arima") {
me = list()
pred_me = matrix(NA, nrow(B), 1)
if(is.null(arformula)){
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_b ==n)] = as.numeric(forecast(me[[n]], h = length(time_b[which(id_b == n)]))$fitted)
}
} else {
for(n in unique(id_a)){
me[[n]] = arima(gamma[n == id_a], order = arformula, method = "ML")
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
}
# for(n in unique(id_a)){
#   pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
# }
}
if(model == "lme") {
me = sapply(1:ncol(alpha), function(j) lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma[,j], time = time_a, id = id_a), REML = TRUE))
pred_me = sapply(1:ncol(alpha), function(j) predict(me[[j]], newdata = data.frame(time = time_b, id = id_b), allow.new.levels = TRUE, re.form = NULL))
}
beta = t(B) %*% pred_me #NAS IN PREDME
rm(me, pred_me)
beta = apply(rbind(beta,nonzero_b), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
zeta = B %*% beta
dist = sqrt(colSums(zeta^2))
zeta = sweep(zeta, 2, dist, "/")
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$fitted)
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
}
# for(n in unique(id_b)){
#   pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
# }
}
if(model == "lme") {
me = sapply(1:ncol(beta), function(j) lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta[,j], time = time_b, id = id_b), REML = TRUE))
pred_me = sapply(1:ncol(beta), function(j) predict(me[[j]], newdata = data.frame(time = time_a, id = id_a), allow.new.levels = TRUE, re.form = NULL))
}
alpha = t(A) %*% pred_me
rm(me, pred_me)
alpha = apply(rbind(alpha,nonzero_a), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
if(length(nonzero_a) == 1) e = mean(abs(gamma - varTol1)) + mean(abs(zeta - varTol2))
if(length(nonzero_a) > 1) e  = mean(colMeans(abs(gamma - varTol1))) + mean(colMeans(abs(zeta - varTol2)))
textSCCA = paste0(" Common convergence error: ", round(e, 5), " & Iterations: ", i)
if(isFALSE(silent) & (e<= tol || i > iter)) cat(textSCCA, "\r")
}
if(model == "lme") {
me_x = lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma, time = time_a, id = id_a), REML = TRUE)
me_y = lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta, time = time_b, id = id_b), REML = TRUE)
} else {
me_x = NULL
me_y = NULL
}
return(list(a = alpha, b = beta, conv = e, iter = i, me_x = me_x, me_y = me_y))
}
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
toscca.core
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
dim(ATrain)
dim(BTrain)
A = scale_rm(X0, centre = T); B = scale_rm(Y0, centre = T)
nonzero_a = c(10, 100, 1000)
nonzero_b = c(10, 20, 80)
N = min(nrow(A), nrow(B)) # observations
p = ncol(A) - 2 # predictor variables (not really since CCA is symmetric)
q = ncol(B) - 2# response variables (not really since CCA is symmetric)
s = rep(1:folds, times=ceiling(N/folds))
s = s[1:N]
s = s[sample(1:length(s), length(s))]
if(folds == 1) s[sample(1:N, 0.25*N)] = 2
nonzeroGrid = expand.grid(nonzero_a, nonzero_b)
h = nrow(nonzeroGrid)
canCor = matrix(NA, folds, h)
alphaMat <- list()
betaMat  <- list()
ATrain = A[s!=f, ]
BTrain = B[s!=f, ]
dim(ATrain)
dim(BTrain)
N
length(s)
dimA
dim(A)
dim(B)
dim(X0)
table(s)
ATest  = A[s==f, ]
BTest  = B[s!=f, ]
ATest  = A[s!=f, ]
ATrain = A[s==f, ]
BTrain = B[s==f, ]
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
dim(ATrain)
dim(BTrain)
alphaInit = runif(ncol(A)-2)
A = ATrain
B = BTrain
nonzero_a = nonzeroGrid[,1]
nonzero_b = nonzeroGrid[,2]
model
list.of.packages <- c("lme4", "forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
# checks
if(ncol(B) <= max(nonzero_b)) {
message("At least one of the nonzero options for B is not sparse. Changing to meet criteria")
nonzeroB = nonzero_b[nonzero_b < (ncol(B) - 2)]
}
if(ncol(A) <= max(nonzero_a)) {
message("At least one of the nonzero options for A is not sparse. Changing to meet criteria")
nonzero_a = nonzero_a[nonzero_a < (ncol(A) - 2)]
}
#Create the matrix A
alpha = sapply(nonzero_a, function(x) c(alphaInit))
varTol1 = matrix(0, nrow = nrow(A), ncol = length(nonzero_a))
varTol2 = matrix(0, nrow = nrow(B), ncol = length(nonzero_b))
i = 0
e = 10
# format data
id_a = A[,"id"]
id_b = B[,"id"]
time_a = A[,"time"]
time_b = B[,"time"]
A = as.matrix(A[, 3:ncol(A)])
B = as.matrix(B[, 3:ncol(B)])
while (e > tol & i <= iter) {
i = i +1
# refresh
if(i > 1) varTol1 = gamma
if(i > 1) varTol2 = zeta
gamma =  A %*% alpha
dist  = sqrt(colSums(gamma^2))
gamma = sweep(gamma, 2, dist, "/")
if(length(model) != 1 | !(model %in% c("arima", "lme"))) {
model = "lme"
lmeformula = " ~ -1 + time + (1|id)"
print("Model not correctly specify. \n Default is lme with formula ~ -1 + time + (1|id)")
}
if(model == "arima") {
me = list()
pred_me = matrix(NA, nrow(B), 1)
if(is.null(arformula)){
for(n in unique(id_a)){
me[[n]] = auto.arima(gamma[n == id_a],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_b ==n)] = as.numeric(forecast(me[[n]], h = length(time_b[which(id_b == n)]))$fitted)
}
} else {
for(n in unique(id_a)){
me[[n]] = arima(gamma[n == id_a], order = arformula, method = "ML")
pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
}
}
# for(n in unique(id_a)){
#   pred_me[which(id_b ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_b[which(id_b == n)]))$pred)
# }
}
if(model == "lme") {
me = sapply(1:ncol(alpha), function(j) lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma[,j], time = time_a, id = id_a), REML = TRUE))
pred_me = sapply(1:ncol(alpha), function(j) predict(me[[j]], newdata = data.frame(time = time_b, id = id_b), allow.new.levels = TRUE, re.form = NULL))
}
beta = t(B) %*% pred_me #NAS IN PREDME
rm(me, pred_me)
beta = apply(rbind(beta,nonzero_b), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
zeta = B %*% beta
dist = sqrt(colSums(zeta^2))
zeta = sweep(zeta, 2, dist, "/")
if(model == "arima") {
me = list()
pred_me = matrix(NA, length(gamma), 1)
if(is.null(arformula)){
for(n in unique(id_b)){
me[[n]] = auto.arima(zeta[n == id_b],max.p = 5,max.q = 5,max.P = 5,max.Q = 5,max.d = 3,seasonal = FALSE,ic = 'aicc')
pred_me[which(id_a ==n)] = as.numeric(forecast(me[[n]], h = length(time_a[which(id_a == n)]))$fitted)
}
} else {
for(n in unique(id_b)){
me[[n]] = arima(zeta[n == id_b], order = arformula, method = "ML")
pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
}
}
# for(n in unique(id_b)){
#   pred_me[which(id_a ==n)] = as.numeric(predict(me[[n]], n.ahead = length(time_a[which(id_a == n)]))$pred)
# }
}
if(model == "lme") {
me = sapply(1:ncol(beta), function(j) lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta[,j], time = time_b, id = id_b), REML = TRUE))
pred_me = sapply(1:ncol(beta), function(j) predict(me[[j]], newdata = data.frame(time = time_a, id = id_a), allow.new.levels = TRUE, re.form = NULL))
}
alpha = t(A) %*% pred_me
rm(me, pred_me)
alpha = apply(rbind(alpha,nonzero_a), 2, function(x)
{
nonzero1 = x[length(x)]
y = x[-length(x)]
thres = abs(y)[order(abs(y), decreasing=TRUE)[nonzero1+1]]
tmp = (abs(y) - thres)
tmp[tmp<=0] = 0
sign(y) * tmp
})
if(length(nonzero_a) == 1) e = mean(abs(gamma - varTol1)) + mean(abs(zeta - varTol2))
if(length(nonzero_a) > 1) e  = mean(colMeans(abs(gamma - varTol1))) + mean(colMeans(abs(zeta - varTol2)))
textSCCA = paste0(" Common convergence error: ", round(e, 5), " & Iterations: ", i)
if(isFALSE(silent) & (e<= tol || i > iter)) cat(textSCCA, "\r")
}
me_x = sapply(1:ncol(alpha), function(j) lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma[,j], time = time_a, id = id_a), REML = TRUE))
# lmer(as.formula(paste("gamma", lmeformula)), data = data.frame(gamma = gamma, time = time_a, id = id_a), REML = TRUE)
me_y = sapply(1:ncol(beta), function(j) lmer(as.formula(paste("zeta", lmeformula)), data = data.frame(zeta = zeta[,j], time = time_b, id = id_b), REML = TRUE))
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
nonzero_a = c(10, 100, 1000)
nonzero_b = c(10, 20, 80)
A = scale_rm(X0, centre = T); B = scale_rm(Y0, centre = T)
N = min(nrow(A), nrow(B)) # observations
p = ncol(A) - 2 # predictor variables (not really since CCA is symmetric)
q = ncol(B) - 2# response variables (not really since CCA is symmetric)
s = rep(1:folds, times=ceiling(N/folds))
s = s[1:N]
s = s[sample(1:length(s), length(s))]
if(folds == 1) s[sample(1:N, 0.25*N)] = 2
nonzeroGrid = expand.grid(nonzero_a, nonzero_b)
h = nrow(nonzeroGrid)
canCor = matrix(NA, folds, h)
alphaMat <- list()
betaMat  <- list()
ATrain = A[s==f, ]
BTrain = B[s==f, ]
if(!is.null(ATest_res)) ATest = ATest_res[s!=f, ]
if(is.null(ATest_res)) ATest  = A[s!=f, ]
if(!is.null(BTest_res)) BTest = BTest_res[s!=f, ]
ATest  = A[s!=f, ]
BTest  = B[s!=f, ]
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
betaMat[[f]]  <- resultKFold$b
gamma = standardVar(ATest%*%alphaMat[[f]], centre = FALSE)
gamma = scale_rm(ATest%*%alphaMat[[f]], centre = FALSE)
alphaMat
alphaMat[[f]] <- resultKFold$a
betaMat[[f]]  <- resultKFold$b
gamma = scale_rm(ATest%*%alphaMat[[f]], centre = FALSE)
gamma = scale_rm(as.matrix(ATest[,3:(p+2)])%*%alphaMat[[f]], centre = FALSE)
as.matrix(ATest[,3:(p+2)])%*%alphaMat[[f]]
gamma = data.frame(id = A$id, time = B$time, x = as.matrix(ATest[,3:(p+2)])%*%alphaMat[[f]])
gamma = data.frame(id = A$id, time = A$time, x = as.matrix(ATest[,3:(p+2)])%*%alphaMat[[f]])
gamma = data.frame(id = ATest$id, time = ATest$time, x = as.matrix(ATest[,3:(p+2)])%*%alphaMat[[f]])
gamma = scale_rm(gamma, centre = FALSE)
zeta = data.frame(id = BTest$id, time = BTest$time, x = as.matrix(BTest[,3:(p+2)])%*%betaMat[[f]])
zeta  = scale_rm(zeta, centre = TRUE)
zeta = data.frame(id = BTest$id, time = BTest$time, x = as.matrix(BTest[,3:(p+2)])%*%betaMat[[f]])
zeta = data.frame(id = BTest$id, time = BTest$time, x = as.matrix(BTest[,3:(q+2)])%*%betaMat[[f]])
zeta  = scale_rm(zeta, centre = TRUE)
if(ncol(gamma) + ncol(zeta) > 2) canCor[f,]  = abs(sapply(1:ncol(gamma), function(j) cor(gamma[,j], zeta[,j])))
gamma
(ncol(gamma)
)
canCor
abs(cor(gamma, zeta))
abs(sapply(1:ncol(gamma), function(j) cor(gamma[,j], zeta[,j])))
ncol(gamma)
ncol(zeta)
if(ncol(gamma) + ncol(zeta) > 2) canCor[f,]  = abs(sapply(3:ncol(gamma), function(j) cor(gamma[,j], zeta[,j])))
dim(gamma)
dim(zeta)
dim(ATrain)
dim(ATest)
dim(BTest)
dim(BTrain)
table(gamma[gamma$id === 1])
table(gamma[gamma$id == 1])
table(gamma[gamma$id == 1,])
View(gamma)
table(gamma[gamma$id == 3,])
(gamma[gamma$id == 3,])
(zeta[zeta$id == 3,])
colMeans(gamma[,j])
j
j = 3
colMeans(gamma[,j])
rowMeans(gamma[,j])
gamma[,j]
gammaT <- aggregate(. ~ id + time, data = gamma, FUN = mean)
gammaT
zettaT <- aggregate(. ~ id + time, data = zeta, FUN = mean)
if(ncol(gamma) + ncol(zeta) > 2) canCor[f,]  = abs(sapply(3:ncol(gamma), function(j) cor(gammaT[,j], zettaT[,j])))
dim(gammaT)
dim(zettaT)
zettaT <- aggregate(. ~ id , data = zeta, FUN = mean)
gammaT <- aggregate(. ~ id , data = gamma, FUN = mean)
gammaT
if(ncol(gamma) + ncol(zeta) > 2) canCor[f,]  = abs(sapply(3:ncol(gamma), function(j) cor(gammaT[,j], zettaT[,j])))
dim(gammaT)
dim(zettaT)
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
resultKFold = toscca.core(alphaInit = runif(ncol(A)-2), A = ATrain, B = BTrain, nonzero_a = nonzeroGrid[,1], nonzero_b = nonzeroGrid[,2], model = model, lmeformula = lmeformula, silent = silent)
alphaMat[[f]] <- resultKFold$a
betaMat[[f]]  <- resultKFold$b
gamma = sapply(1:ncol(alphaMat[[f]]), function(j) predict(resultKFold$me_x[[j]], newdata = data.frame(time = ATest[,"id"], id = ATest), allow.new.levels = TRUE, re.form = NULL))
gamma = sapply(1:ncol(alphaMat[[f]]), function(j) predict(resultKFold$me_x[[j]], newdata = data.frame(time = ATest[,"time"], id = ATest[,id""]), allow.new.levels = TRUE, re.form = NULL))
gamma = sapply(1:ncol(alphaMat[[f]]), function(j) predict(resultKFold$me_x[[j]], newdata = data.frame(time = ATest[,"time"], id = ATest[,"id"]), allow.new.levels = TRUE, re.form = NULL))
gamma = scale_rm(gamma, centre = FALSE)
gamma = sapply(1:ncol(alphaMat[[f]]), function(j) predict(resultKFold$me_x[[j]], newdata = data.frame(time = ATest[,"time"], id = ATest[,"id"]), allow.new.levels = TRUE, re.form = NULL))
gamma = data.frame(id = ATest$id, time = ATest$time, x = gamma)
gamma = scale_rm(gamma, centre = FALSE)
zeta = sapply(1:ncol(betaMat[[f]]), function(j) predict(resultKFold$me_y[[j]], newdata = data.frame(time = ATest[,"time"], id = ATest[,"id"]), allow.new.levels = TRUE, re.form = NULL))
zeta = data.frame(id = ATest$id, time = ATest$time, x = zeta)
zeta  = scale_rm(zeta, centre = TRUE)
if(ncol(gamma) + ncol(zeta) > 2) canCor[f,]  = abs(sapply(3:ncol(gamma), function(j) cor(gamma[,j], zeta[,j])))
canCor
canCorKMeans = colSums(abs(canCor))/folds
select       = getWhich(abs(canCorKMeans), max)
toscca:::getWhich()
toscca:::getWhich
getWhich <- function (data, fun)
{
fun = match.fun(fun)
position = (which(data == fun(data)))
position
}
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds_CORE.R")
select       = getWhich(abs(canCorKMeans), max)
canCorPrint  = canCorKMeans[select]
select
names(canCorPrint) <- ("k-fold cv max. cancor")
if(isFALSE(silent)) cat("\n")
if(isFALSE(silent)) print(canCorPrint)
if(isFALSE(silent)) {
cat("\n ........................................ \n",
paste0("# nonzero A: ", nonzeroGrid[select, 1],   "\n",
" # nonzero B: ", nonzeroGrid[select, 2],
"\n ........................................ \n"))
}
if(toPlot & nrow(nonzeroGrid) > 1) {
mat = matrix(canCor, nrow = length(nonzero_a), ncol = length(nonzero_b))
rownames(mat) = nonzero_a
colnames(mat) = nonzero_b
myHeatmap(mat)
}
mat = matrix(canCor, nrow = length(nonzero_a), ncol = length(nonzero_b))
rownames(mat) = nonzero_a
colnames(mat) = nonzero_b
myHeatmap(mat)
#' Plots grid of CC over threshold penalty
#'
#'
#' @param mat A square matrix nxm.
#' @param pallette Character. Name of pallette colour. Default is Teal.
#' @param coln Integer. Grid length parameter.
#' @param xlab Character. Label for x axis.
#' @param ylab Character. Label for y axis.
#' @param axes Logical. If TRUE, axes are between 0 and 1.
#' @return Grid plot.
myHeatmap = function (mat, palette = "Teal", coln = 12, xlab = "", ylab = "", axes = FALSE)
{
par(fig = c(0, 7/10, 0, 1))
image(mat, col = hcl.colors(length(mat), palette, rev = TRUE), axes = axes, xlab = xlab, ylab = ylab)
if(isFALSE(axes)) {
axis(1, seq(0, 1, length = nrow(mat)), rownames(mat))
axis(2, seq(0, 1, length = ncol(mat)), colnames(mat), las = 1)
}
# if (as == "i") {
#   axis(1, seq(0, 1, length = nrow(mat)), c(1:nrow(mat)),
#        tck = FALSE)
#   axis(2, seq(0, 1, length = ncol(mat)), c(1:ncol(mat)),
#        tck = FALSE)
# }
par(fig = c(7/10, 1, 0, 1), new = TRUE)
colvec = matrix(seq(min(mat), max(mat), length = coln))
image(t(colvec), col = hcl.colors(coln, palette, rev = TRUE), axes = FALSE)
axis(2, seq(0.0625, 1, length = 10/2), format(colvec[seq(2,
10, 2)], digits = 3, nsmall = 2), las = 1)
par(fig = c(0, 1, 0, 1))
}
myHeatmap(mat)
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds.R")
A = scale_rm(X0, centre = T); B = scale_rm(Y0, centre = T)
nonzero_a = c(10, 100, 1000, 5000)
nonzero_b = c(10, 20, 80)
res_search = toscca.folds(A, B, nonzero_a, nonzero_b, alpha_init = "uniform", folds = 1, parallel_logic = FALSE, silent = FALSE, toPlot = TRUE, ATest_res = NULL, BTest_res = NULL, model = "lme", lmeformula = " ~ poly(time,3) + (1+time|id)", arformula = c(1,0,0))
res_search$alpha
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds.R")
res_search = toscca.folds(A, B, nonzero_a, nonzero_b, alpha_init = "uniform", folds = 1, parallel_logic = FALSE, silent = FALSE, toPlot = TRUE, ATest_res = NULL, BTest_res = NULL, model = "lme", lmeformula = " ~ poly(time,3) + (1+time|id)", arformula = c(1,0,0))
res_search$alpha
plot(res_search$alpha)
res_search_timeA = res_search
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds.R")
res_search = toscca.folds(A, B, nonzero_a, nonzero_b, alpha_init = "uniform", folds = 1, parallel_logic = FALSE, silent = FALSE, toPlot = TRUE, ATest_res = NULL, BTest_res = NULL, model = "lme", lmeformula = " ~ poly(time,3) + (1+time|id)", arformula = c(1,0,0))
source("C:/Users/PC/OneDrive/github/sccamm/scripts/toscca_me_ar_folds.R")
res_search = toscca.folds(A, B, nonzero_a, nonzero_b, alpha_init = "uniform", folds = 1, parallel_logic = FALSE, silent = FALSE, toPlot = TRUE, ATest_res = NULL, BTest_res = NULL, model = "lme", lmeformula = " ~ poly(time,3) + (1+time|id)", arformula = c(1,0,0))
plot(res_search$alpha)
points(res_search_timeA$alpha, col = 3)
save.image("C:/Users/PC/OneDrive/github/sccamm/scripts/im.RData")
save.image("C:/Users/PC/OneDrive/github/sccamm/scripts/image_standCheck.RData")
gamma_1 = data.frame(id = X$id, time = X$time, x = as.matrix(X[,3:ncol(X)])%*%res_search$alpha)
zeta_1 = data.frame(id = Y$id, time = Y$time, x = as.matrix(Y[,3:ncol(Y)])%*%res_search$beta)
pg_1 = ggplot(gamma_1[gamma_1$time%in% 1:30, ], aes(x = time, y = x, group = id, color = id)) +
geom_line(show.legend = FALSE) +
labs(x = "Time", y = "X", title = "gamma vs Time for Each ID") +
theme_minimal()
pz_1 =ggplot(zeta_1[zeta_1$time %in% 1:30,], aes(x = time, y = x, group = id, color = id)) +
geom_line(show.legend = FALSE) +
labs(x = "Time", y = "X", title = "zeta vs Time for Each ID") +
theme_minimal()
gridExtra::grid.arrange(pg_1, pz_1, nrow = 1)
# residu
type = "basic"
# per timepoint: REALLY BAD
X_res = matrix(NA, 0, ncol = (ncol(X)-2))
Y_res = matrix(NA, 0, ncol = (ncol(Y)-2))
for (i in unique(X$time)) {
X_res = rbind(X_res, residualisation(as.matrix(X[X$time==i,3:ncol(X)]), res_toscca$a, type = type))
# Y_res = residualisation(as.matrix(Y[,3:ncol(Y)]), res_toscca$b, type = type)
}
for (i in unique(Y$time)) {
Y_res = rbind(Y_res, residualisation(as.matrix(Y[Y$time==i,3:ncol(Y)]), res_toscca$b, type = type))
}
